# sys_top 模块数据流分析

## 整体架构

```
输入 -> 中央控制器 -> 四种工作模式 -> UART输出
```

## 主要数据流路径

### 1. 数据输入模式 (Data Input Mode)
**流程**: UART RX → Parser → Matrix Storage → Matrix Printer → UART TX

**详细连线**:
```
uart_rxd (物理输入)
  ↓
uart_rx (接收模块)
  ├─ uart_rx_done → uart_parser.rx_done
  └─ uart_rx_data → uart_parser.rx_data
         ↓
uart_parser (解析模块)
  ├─ parsed_m (矩阵行数)
  ├─ parsed_n (矩阵列数)
  ├─ parsed_matrix_flat (矩阵数据200位)
  └─ parse_done (解析完成信号)
         ↓
store_write_en逻辑 (存储控制)
  ├─ store_mat_col ← parsed_m
  ├─ store_mat_row ← parsed_n
  └─ store_data_flow ← parsed_matrix_flat
         ↓
matrix_storage (存储模块)
  ├─ info_table (矩阵信息表)
  └─ total_count (矩阵总数)

同时:
parse_done (解析完成)
  ↓
matrix_printer (u_print_for_parse)
  ├─ matrix_flat ← parsed_matrix_flat
  ├─ dimM ← parsed_m
  ├─ dimN ← parsed_n
  ├─ uart_tx_en_parse → UART TX MUX
  └─ uart_tx_data_parse → UART TX MUX
         ↓
UART TX多路复用器 (根据data_input_mode_en选择)
  ├─ uart_tx_en → uart_tx模块
  └─ uart_tx_data → uart_tx模块
         ↓
uart_txd (物理输出)
```

### 2. 生成模式 (Generate Mode)
**流程**: UART RX → Generate Operate → Matrix Storage + Matrix Printer → UART TX

**详细连线**:
```
uart_rx_data + uart_rx_done
  ↓
generate_mode (生成控制模块)
  ├─ gen_m (生成的矩阵行数)
  ├─ gen_n (生成的矩阵列数)
  ├─ gen_flow (生成的矩阵数据200位)
  ├─ gen_done (生成完成)
  ├─ gen_valid (生成有效信号)
  └─ gen_error (生成错误)
         ↓
store_write_en逻辑 (当gen_valid=1时)
  ├─ store_mat_col ← gen_m
  ├─ store_mat_row ← gen_n
  └─ store_data_flow ← gen_flow
         ↓
matrix_storage (存储到矩阵仓库)

同时:
gen_valid
  ↓
matrix_printer (u_print_for_generate)
  ├─ matrix_flat ← gen_flow
  ├─ dimM ← gen_m
  ├─ dimN ← gen_n
  ├─ uart_tx_en_gen → UART TX MUX
  └─ uart_tx_data_gen → UART TX MUX
         ↓
UART TX (输出生成的矩阵)
```

### 3. 显示模式 (Display Mode)
**流程**: Display Mode Enable → Matrix Selector → Print Table 或 Print Specified Matrix → UART TX

**详细连线**:

#### 3.1 打印表格子流程
```
display_mode_en (显示模式使能)
  ↓
matrix_selector_display (选择控制器)
  └─ print_table_start (启动打印表格)
         ↓
print_table (表格打印模块)
  ├─ info_table ← matrix_storage.info_table (矩阵信息)
  ├─ cnt ← total_count (矩阵总数)
  ├─ uart_tx_en_table → Display MUX
  ├─ uart_tx_data_table → Display MUX
  ├─ print_busy_table (忙状态)
  └─ print_done_table → matrix_selector_display
         ↓
UART TX Display MUX
  ├─ 如果print_busy_table=1: 输出table数据
  └─ 否则: 输出spec数据
```

#### 3.2 打印指定矩阵子流程
```
uart_rx (用户输入行列数)
  ↓
matrix_selector_display
  ├─ spec_dim_m (目标矩阵行数)
  ├─ spec_dim_n (目标矩阵列数)
  └─ print_spec_start (启动打印指定矩阵)
         ↓
print_specified_dim_matrix (查询并打印模块)
  ├─ 输入: info_table (查询匹配的矩阵)
  ├─ 输出: store_read_en (读使能)
  ├─ 输出: store_rd_col, store_rd_row, store_rd_mat_index
  └─ 等待: store_rd_ready
         ↓
matrix_storage (读取接口)
  └─ store_rd_data_flow (读取的矩阵数据)
         ↓
print_specified_dim_matrix
  ├─ matrix_flat (传递给打印器)
  └─ matrix_print_start (启动打印)
         ↓
matrix_printer (u_print_for_display)
  ├─ matrix_flat (矩阵数据)
  ├─ dimM ← spec_dim_m
  ├─ dimN ← spec_dim_n
  ├─ uart_tx_en_spec → Display MUX
  └─ uart_tx_data_spec → Display MUX
         ↓
UART TX (输出矩阵)
```

### 4. 计算模式 (Calculation Mode)
**流程**: 待实现

```
calculation_mode_en
  ↓
(待连接计算子系统)
```

## UART TX 多路复用逻辑

```verilog
always @(*) begin
    if (data_input_mode_en) begin
        // 数据输入模式: 输出解析后的矩阵
        uart_tx_en = uart_tx_en_parse;
        uart_tx_data = uart_tx_data_parse;
    end else if (generate_mode_en) begin
        // 生成模式: 输出生成的矩阵
        uart_tx_en = uart_tx_en_gen;
        uart_tx_data = uart_tx_data_gen;
    end else if (display_mode_en) begin
        // 显示模式: 输出表格或指定矩阵
        uart_tx_en = uart_tx_en_display;
        uart_tx_data = uart_tx_data_display;
    end else begin
        uart_tx_en = 1'b0;
        uart_tx_data = 8'd0;
    end
end

// Display模式内部的二级多路复用
assign uart_tx_en_display = print_busy_table ? uart_tx_en_table : uart_tx_en_spec;
assign uart_tx_data_display = print_busy_table ? uart_tx_data_table : uart_tx_data_spec;
```

## LED指示灯信号

### LED[7:0] - 模式指示
```
led[0] = calculation_mode_en   // 计算模式
led[1] = display_mode_en        // 显示模式
led[2] = generate_mode_en       // 生成模式
led[3] = data_input_mode_en     // 数据输入模式
led[7:4] = 4'b0                 // 保留
```

### LD2[7:0] - 状态指示
```
ld2[0] = led0_on           // 矩阵存储指示 (store_write_en触发)
ld2[1] = led1_on           // 生成完成指示 (gen_done触发)
ld2[2] = led2_on           // 生成错误指示 (gen_error触发)
ld2[3] = led3_on           // 生成有效指示 (gen_valid触发)
ld2[7:4] = ~debug_state    // 调试状态 (print_table状态机)
```

## Matrix Storage 接口

### 写接口 (由Parser和Generate共享)
```
store_write_en    : 写使能 (parse_done或gen_valid时为1)
store_mat_col     : 矩阵列数
store_mat_row     : 矩阵行数
store_data_flow   : 矩阵数据流 (200位)
```

### 读接口 (由Display模式使用)
```
store_read_en     : 读使能 (来自print_specified_dim_matrix)
store_rd_col      : 读取的矩阵列数
store_rd_row      : 读取的矩阵行数
store_rd_mat_index: 读取的矩阵索引
store_rd_data_flow: 读取的矩阵数据流 (200位)
store_rd_ready    : 读取就绪信号
store_err_rd      : 读取错误信号
```

### 状态输出
```
info_table[49:0]  : 矩阵信息表 (最多10个矩阵，每个5字节)
total_count[7:0]  : 已存储的矩阵总数
```

## 按键信号

```
btn_confirm → btn_debouncer → btn_confirm_db → Central_Controller
btn_exit → btn_debouncer → btn_exit_db → Central_Controller
```

## 关键控制信号

### 中央控制器输出
```
data_input_mode_en    : 数据输入模式使能
generate_mode_en      : 生成模式使能
display_mode_en       : 显示模式使能
calculation_mode_en   : 计算模式使能 (待实现)
```

## 未使用的输出端口

以下输出端口已声明但未连接:
```
dk1_segments[7:0]     : 数码管1段码 (已注释assign为8'd0)
dk2_segments[7:0]     : 数码管2段码 (已注释assign为8'd0)
dk_digit_select[7:0]  : 数码管位选   (已注释assign为8'd0)
```

## 数据宽度规格

- **矩阵数据流**: 200位 (25个8位元素)
- **矩阵维度**: 3位 (最大7x7矩阵，实际使用5x5)
- **UART数据**: 8位
- **矩阵索引**: 2位 (最多4个矩阵)
- **信息表**: 50位 (10个矩阵 × 5字节)

## 需要注意的问题

1. **matrix_selector_display模块的连接**: 当前版本中，该模块的storage和printer接口被置空，实际连接通过print_specified_dim_matrix模块完成
2. **矩阵维度信号**: matrix_printer的dimM/dimN在display模式下直接使用spec_dim_m/n，需要确保这些维度与实际读取的矩阵匹配
3. **Display模式多路复用**: 使用print_busy_table作为选择信号，在打印表格和打印矩阵之间切换
